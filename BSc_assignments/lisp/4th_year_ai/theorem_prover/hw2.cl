(setq literals '(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z))
(setf subs '())
(setf clauses '())
(setf new_thm '())
(setf proved '())

(defun doesInclude (lit expression)
	(cond ((equal expression '()) '())
		((equal expression lit) t)
		((listp expression)
			(or (doesInclude lit (car expression)) (doesInclude lit (cdr expression))))
		(t  '())))

(defun setSubs (new_sub)
	(let ((A (car (remove '() (mapcar (lambda (x) (if (equal (car x) (car new_sub)) x '())) subs)))))
	(if (or A (doesInclude (car new_sub) (cadr new_sub)))
            (if (and (not (equal A '())) (equal (cadr new_sub) (cadr  A))) t
		(let ((result '()))
			(setf subs '()) '()))
		(let ((result t))
			(setf subs (cons new_sub subs)) t))))

(defun checkEqv (pred1 pred2)
	(if (member pred1 literals) '()
		(setSubs (list pred1 pred2))))

(defun isEqualHelper (pred1 pred2)
	(cond ((and (listp pred1) (listp pred2)) (isEqual pred1 pred2))
		((and (listp pred1) (not (listp pred2))) (checkEqv pred2 pred1))
		((and (listp pred2) (not (listp pred1))) (checkEqv pred1 pred2))
		((equal pred1 pred2) t)
		((and (member pred1 literals) (member pred2 literals)) '())
		((member pred1 literals) (setSubs (list pred2 pred1)))
		((member pred2 literals) (setSubs (list pred1 pred2)))
		((and (not (equal pred1 '~)) (not (equal pred2 '~))) (setSubs (list pred1 pred2)))))

(defun isEqual2 (pred1 pred2)
        (cond ((and (equal pred1 '()) (equal pred2 '())) t)
                ((and (equal pred1 '()) (not (equal pred2 '()))) '())
                ((and (equal pred2 '()) (not (equal pred1 '()))) '())
		((equal (isEqualHelper (car pred1) (car pred2)) '()) 
			(setf subs '()) '())
		(t (isEqual2 (cdr pred1) (cdr pred2)))))

(defun isEqual (pred1 pred2)
	(cond ((and (equal pred1 '()) (equal pred2 '())) t)
                ((and (equal pred1 '()) (not (equal pred2 '()))) '())
                ((and (equal pred2 '()) (not (equal pred1 '()))) '())
		((and (equal (car pred1) (car pred2)) (equal (car pred1) '~)) (isEqual (cdr pred1) (cdr pred2))) 
		((and (equal (car pred1) (car pred2)) (not (equal (car pred1) '~))) (isEqual2 (cdr pred1) (cdr pred2)))
		(t '())))

(defun negate (soln)
	(if (equal (car soln) '~) (cdr soln)
		(cons '~ soln)))

(defun applySub3 (sub clause)
	(cond ((equal clause '()) '())
		((equal clause (car sub)) (cadr sub))
		((listp clause) (cons (applySub3 sub (car clause)) (applySub3 sub (cdr clause))))
		(t clause)))

(defun applySub2 (new_subs clause)
	(if (equal new_subs '()) clause
		(applySub2 (cdr new_subs) (applySub3 (car new_subs) clause))))

(defun applySub (clauses)
	(mapcar (lambda (x) 
		(if (equal (car x) '~) (append (list (car x) (cadr x)) (applySub2 subs (cddr x)))
			(cons (car x) (applySub2 subs (cdr x))))) clauses))

(defun decr2 (solx cl1 cl2)
	(setf subs '())
	(if (equal cl2 '()) cl1
		(if (isEqual solx (car cl2)) (applySub (append cl1 (cdr cl2)))
			(decr2 solx (append cl1 (list (car cl2))) (cdr cl2)))))
		
(defun decr1 (soln clause)
	(if (equal soln '()) clause
		(decr1 (cdr soln) (decr2 (negate (car soln)) '() clause))))

(defun decr (soln clause)
	(let ((A (decr1 soln clause)))
		(if (equal A '())
			(if (= (length soln) (length clause))
				(let ((S (list clause soln '())))
					(setf proved t) S)
				(list clause soln))
			(if (equal A clause) '() (list clause soln A)))))

(defun progressOne ()
  (if (equal new_thm '()) '()
    (let* ((SOLN (car new_thm))
      (R (remove '() (mapcar (lambda (x) (decr SOLN x)) clauses))))
	(setf new_thm (cdr new_thm))
	(if (equal R '()) 
	  (progressOne)
	  (if (equal proved t)
	    (remove '() (mapcar (lambda (x) (if (equal (caddr x) '()) x '())) R))
	    (let ((C R))
		(setf new_thm (append (mapcar (lambda (x) (caddr x)) R)  new_thm))
		C))))))

(defun proveHelper2 (way)
	(if (equal proved '())
		(if (equal new_thm '()) '()
			(proveHelper2 (append (progressOne) way)))
		way))

(defun proveHelper (way)
	(let ((A (reverse (proveHelper2 way))))
	(if (equal A '()) '(no)
		(cons 'yes A))))

(defun clear (claus)
	claus)	

(defun prove (claus soln)
	(setf proved '())
	(setf new_thm soln)
	(setf clauses (clear claus)) 
	(proveHelper '()))
