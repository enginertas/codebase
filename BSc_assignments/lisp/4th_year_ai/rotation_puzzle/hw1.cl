(setf open_list '())
(setf closed_st '())
(setf len 0)
(setf limit 0)

(defun calcIndex (i j num)
	(let* ((col (mod (- num 1) len)) 
		(row (/ (- num (+ col 1)) len) ))
			(+ (abs (- i row)) (abs (- j col)))))

(defun calcRow (i row_no config)
	(if (< i len)
		(+ (calcIndex row_no i (nth i config))(calcRow (+ i 1) row_no config)) 0))

(defun heuristic (row_no config)
	(if (< row_no len)
		(+ (calcRow 0 row_no (nth row_no config)) (heuristic (+ row_no 1) config)) 0))

(defun calcMove (config row col move_t)
	(cond ((= move_t 1) (if (> col 1) (list config row (- col 1)) '()))
		((= move_t 2) (if (> row 1) (list config (- row 1) col) '()))
		((= move_t 3) (if (< col limit) (list config row (+ col 1)) '()))
		((= move_t 4) (if (< row limit) (list config (+ row 1) col) '()))))

(defun calcRotLeft (config1 row col)
	(let* ((up (nth (- row 1) config1))
		(leftup (nth (- col 1) up))
		(midup (nth col up))
		(rightup (nth (+ col 1) up))
		(mid (nth row config1))
		(left (nth (- col 1) mid))
		(right (nth (+ col 1) mid))
		(down (nth (+ row 1) config1))
		(leftdown (nth (- col 1) down))
		(middown (nth col down))
		(rightdown (nth (+ col 1) down)))
		(setf (nth (- col 1) up) midup)
		(setf (nth col up) rightup)
		(setf (nth (+ col 1) up) right)
		(setf (nth (+ col 1) mid) rightdown)
		(setf (nth (+ col 1) down) middown)
		(setf (nth col down) leftdown)
		(setf (nth (- col 1) down) left)
		(setf (nth (- col 1) mid) leftup)
		(list config1 row col)))

(defun calcRotRight (config2 row col)
        (let* ((up (nth (- row 1) config2))
                (leftup (nth (- col 1) up))
                (midup (nth col up))
                (rightup (nth (+ col 1) up))
                (mid (nth row config2))
                (left (nth (- col 1) mid))
                (right (nth (+ col 1) mid))
                (down (nth (+ row 1) config2))
                (leftdown (nth (- col 1) down))
                (middown (nth col down))
                (rightdown (nth (+ col 1) down)))
                (setf (nth (- col 1) up) left)
                (setf (nth col up) leftup)
                (setf (nth (+ col 1) up) midup)
                (setf (nth (+ col 1) mid) rightup)
                (setf (nth (+ col 1) down) right)
                (setf (nth col down) rightdown)
                (setf (nth (- col 1) down) middown)
                (setf (nth (- col 1) mid) leftdown)
                (list config2 row col)))

(defun copySub (row)
	(mapcar (lambda (x) (if (numberp x) x '())) row))
(defun copy (conf)
	(mapcar (lambda (x) (copySub x)) conf))

(defun findAdjStates (cur_state goal_cost) 
	(let* ((config (car cur_state))
		(config1 (copy config))
		(config2 (copy config))
		(row (cadr cur_state))
		(col (caddr cur_state))
		(adj_st (list (list (calcMove config row col 1) 1)
		      (list (calcMove config row col 2) 2)
		      (list (calcMove config row col 3) 3)
		      (list (calcMove config row col 4) 4)
		      (list (calcRotLeft config1 row col) 5)
		      (list (calcRotRight config2 row col) 6))))
		(remove '() (mapcar (lambda (st) (if (car st) st '())) adj_st)))) 

(defun elToList (st unproc proc total) 
	(if (not unproc) (append proc (list st))
		(let* ((head (car unproc))
			(head_cost (+ (caddr head) (cadddr head))))    
		(if (> total head_cost) (elToList st (cdr unproc) (append proc (list head)) total)
			(append proc (list st) unproc)))))

(defun mergeLst (to_merge open_list)
	(if (not to_merge) open_list
		(mergeLst (cdr to_merge) (elToList (car to_merge) 
			open_list '() (+ (caddr (car to_merge)) (cadddr (car to_merge)))))))


(defun findOldSt (st_pos unproc proc)
	(if (equal st_pos (caar unproc)) (car unproc)
		(findOldSt st_pos (cdr unproc) (append proc (list (car unproc))))))

(defun elToUpdate (st open_list total)
	(let* ((st_pos (car st))
		(old_st (findOldSt st_pos open_list '()))
		(old_cost (+ (caddr old_st) (cadddr old_st))))
	(if (total < old_cost) (elToList st (remove old_st open_list) '() total) open_list)))

(defun updateLst (to_update open_list)
	(if (not to_update) open_list
		(updateLst (cdr to_update) (elToUpdate (car to_update) 
			open_list (+ (caddr (car to_update)) (cadddr (car to_update)))))))

(defun findOptSol ()
  (if (not open_list) '()
    (let* ((cur_lst (car open_list)) 
      (rest_open (cdr open_list))
      (state (car cur_lst))
      (state_path (cadr cur_lst))
      (goal_cost (caddr cur_lst))
      (heur_cost (cadddr cur_lst))
      (adj_states (findAdjStates state goal_cost))
      (remaining_adj (remove '() (mapcar (lambda (st) (if (member (car st) closed_st) '() st)) adj_states)))
      (new_open_st (mapcar (lambda (lst) (car lst)) open_list))
      (states_to_merge (remove '() (mapcar (lambda (st) (if (member (car st) new_open_st) '() st))  remaining_adj)))
      (states_to_update (set-difference remaining_adj states_to_merge))
      (lst_to_merge (mapcar (lambda (st) 
        (list (car st) (cons (cadr st) state_path)
	  (+ goal_cost  1) (heuristic 0 (caar st)))) states_to_merge))
      (lst_to_update (mapcar (lambda (st)
        (list (car st) (cons (cadr st) state_path) 
	  (+ goal_cost  1) (heuristic 0 (caar st)))) states_to_update)))
      (setf open_list (updateLst lst_to_update (mergeLst lst_to_merge rest_open)))
      (setf open_list (set-difference open_list (nthcdr 100 open_list)))
      (setf closed_st (cons state closed_st))
      (if (= heur_cost 0) state_path
	(findOptSol)))))

(defun convertToSymbol (solved_puzzle)
	(mapcar (lambda (x) 
		(cond 	((= x 1) 'move-left)
			((= x 2) 'move-up)
			((= x 3) 'move-right)
			((= x 4) 'move-down)
			((= x 5) 'rotate-left)
			((= x 6) 'rotate-right)
			(t '()))) solved_puzzle))

(defun solve (config)
	(setf len (length config))
	(setf limit (- len 2))
	(setf open_list (list (list (list config 1 1) '() 0 (heuristic 0 config))))
	(setf closed_st '())
	(convertToSymbol(reverse (findOptSol))))
